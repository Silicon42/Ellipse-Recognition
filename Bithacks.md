This is a (probably incomplete) listing and explainer of bithacks that I used in this project, particularly those unique to OpenCL
+ data structure stuffing: if it fits in 128 bytes, it fits in a single int4 read
+ adjacent pixel vectors: if you assign adjacent pixels to a char8 in clockwise order, you can use a union to index them as an array according to an angle or treat them as longs and mask them for fast parallel truthiness checks even on hardware without native vector support, additionally, you can rotate the long to change the base index
+ coarse angle with occupancy: often due to noise and other effects, only a coarse angle is neccessary for simple calculations, this means a 7-bit fixed precision angle with occupancy flag in the least significant bit allows for fast occupancy checks without the need to mask, angle differences properly roll over at the 360 to 0 degree (or +/- 180 if interpreted as signed) transition, conversion to gray code representation has useful results, and simple differences between 2 angles don't need a mask and give proper angle results as the occupancy bits cancel
+ parallel divide by power of 2 without vector support: using a union with a larger data type (eg, a long), right shift and mask so that the extension from one element that extends into the next is removed
+ parallel add/subtract without vector support: if you know that the values contained cannot over/underflow their positions or over/underflow will not significantly impact the results, such as if you only need very coarse angles, you can safely union them with a larger data type and do the operation there
+ parallel OR, AND, XOR operations without vector support: union with a larger data type and do the operation there, NOTE: these are completely safe with no drawbacks or gotchas